Aqui vai uma proposta de arquitetura RBAC (Role-Based Access Control) para dividir esses cinco perfis de acesso, alinhada a DDD, SOLID e Clean Code:

1. Modelo de domínio (Domain Layer)
Entidades

python
Copiar
Editar
class Role(Entity):
    id: UUID
    name: RoleName  # Enum: ADMIN, DONO_CLINICA, COLAB_N1, COLAB_N2, COLAB_N3, PACIENTE
    permissions: List[Permission]  # Ex.: ["manage_users", "view_financials", ...]

class User(Entity):
    id: UUID
    email: str
    hashed_password: str
    roles: List[Role]
    clinic_id: UUID  # para isolar dados multi-tenant
Value Objects

RoleName (enum)

Permission (string ou outro enum menor)

Regras de Negócio

Herança de permissões: ex. COLAB_N1 herda tudo de PACIENTE + suas próprias ações; DONO_CLINICA herda tudo de COLAB_N3; ADMIN herda tudo de todos.

2. Esquema de banco de dados (Infrastructure Layer)
sql
Copiar
Editar
-- tabela de papéis
CREATE TABLE roles (
  id UUID PRIMARY KEY,
  name TEXT UNIQUE NOT NULL
);

-- tabela de permissões
CREATE TABLE permissions (
  id UUID PRIMARY KEY,
  action TEXT UNIQUE NOT NULL
);

-- associação roles ⇆ permissions
CREATE TABLE role_permissions (
  role_id UUID REFERENCES roles(id),
  permission_id UUID REFERENCES permissions(id),
  PRIMARY KEY(role_id, permission_id)
);

-- usuários
CREATE TABLE users (
  id UUID PRIMARY KEY,
  email TEXT UNIQUE NOT NULL,
  hashed_password TEXT NOT NULL,
  clinic_id UUID NOT NULL
);

-- associação users ⇆ roles
CREATE TABLE user_roles (
  user_id UUID REFERENCES users(id),
  role_id UUID REFERENCES roles(id),
  PRIMARY KEY(user_id, role_id)
);
3. Serviços e casos de uso (Application Layer)
RoleService

assign_role_to_user(user_id, role_name)

get_user_permissions(user_id) → Set[Permission]

AuthService

authenticate(email, password) → JWT(access_token, refresh_token)

no payload do JWT já inclua roles e clinic_id

4. API Layer (FastAPI + Dependências)
Enums e Schemas

python
Copiar
Editar
from enum import Enum

class RoleName(str, Enum):
    ADMIN = "ADMIN"
    DONO_CLINICA = "DONO_CLINICA"
    COLAB_N1 = "COLABORADOR_NIVEL1"
    COLAB_N2 = "COLABORADOR_NIVEL2"
    COLAB_N3 = "COLABORADOR_NIVEL3"
    PACIENTE = "PACIENTE"
Dependência de autorização genérica

python
Copiar
Editar
from fastapi import Depends, HTTPException, status
from jose import jwt

def get_current_user(token: str = Depends(oauth2_scheme)):
    payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
    return UserRepository.get(payload["sub"])

def require_roles(*allowed: RoleName):
    def dependency(user=Depends(get_current_user)):
        user_roles = {r.name for r in user.roles}
        if not user_roles.intersection({r.value for r in allowed}):
            raise HTTPException(status_code=403, detail="Permissão negada")
        return user
    return dependency
Protegendo rotas

python
Copiar
Editar
@router.get("/tenants", dependencies=[Depends(require_roles(RoleName.ADMIN))])
def list_all_tenants():
    ...

@router.post("/clinics/{clinic_id}/users",
             dependencies=[Depends(require_roles(RoleName.ADMIN, RoleName.DONO_CLINICA))])
def create_user_in_clinic(clinic_id: UUID, dto: CreateUserDTO):
    ...

@router.get("/patients/{patient_id}",
            dependencies=[Depends(require_roles(RoleName.ADMIN,
                                               RoleName.DONO_CLINICA,
                                               RoleName.COLAB_N1,
                                               RoleName.COLAB_N2,
                                               RoleName.COLAB_N3,
                                               RoleName.PACIENTE))])
def get_patient(patient_id: UUID, user=Depends(get_current_user)):
    # adicional: garanta que, se for PACIENTE, só acesse seu próprio registro
    if RoleName.PACIENTE in {r.name for r in user.roles} and user.id != patient_id:
        raise HTTPException(403, "Só pode ver seu próprio cadastro")
    ...
5. Frontend (React + Context / Route Guards)
Definição de papéis

ts
Copiar
Editar
export enum Role {
  ADMIN = "ADMIN",
  DONO_CLINICA = "DONO_CLINICA",
  COLAB_N1 = "COLABORADOR_NIVEL1",
  COLAB_N2 = "COLABORADOR_NIVEL2",
  COLAB_N3 = "COLABORADOR_NIVEL3",
  PACIENTE = "PACIENTE"
}
AuthContext

armazena user.roles: Role[]

provê helper hasRole(...roles: Role[]): boolean

Route Guard

tsx
Copiar
Editar
import { Navigate, Outlet } from "react-router-dom";

type PrivateRouteProps = {
  allowed: Role[];
};

const PrivateRoute: React.FC<PrivateRouteProps> = ({ allowed }) => {
  const { user, hasRole } = useAuth();
  if (!user || !hasRole(...allowed)) {
    return <Navigate to="/unauthorized" />;
  }
  return <Outlet />;
};
Uso no Router

tsx
Copiar
Editar
<Routes>
  <Route path="/admin/*" element={<PrivateRoute allowed={[Role.ADMIN]} />}>
    {/* rotas de administração global */}
  </Route>
  <Route path="/clinic/*" element={<PrivateRoute allowed={[Role.ADMIN, Role.DONO_CLINICA]} />}>
    {/* rotas de dono de clínica */}
  </Route>
  <Route path="/dashboard/*" element={<PrivateRoute allowed={[Role.ADMIN, Role.DONO_CLINICA, Role.COLAB_N1, Role.COLAB_N2, Role.COLAB_N3]} />}>
    {/* colaboradores */}
  </Route>
  <Route path="/meus-dados" element={<PrivateRoute allowed={[Role.PACIENTE]} />}>
    {/* paciente */}
  </Route>
</Routes>
Por que esse modelo funciona?
Separação clara de responsabilidades:

Domain Layer cuida apenas de regras de negócio (herança de papéis e permissões).

Infrastructure Layer mapeia para tables relacionais.

Application Layer orquestra use-cases (atribuição de papéis, coleta de permissões).

API Layer expõe endpoints e injeta dependências de autorização.

Frontend reflete essa mesma lógica de roles para exibir/ocultar menus e páginas.

Extensível:

Para adicionar um novo nível de colaborador, basta criar novo RoleName e preencher sua permissão.

Para mudar uma permissão (ex.: dar “editar orçamentos” ao COLAB_N2), atualiza só o role_permissions.

Segurança multi-tenant:

Todo usuário carrega clinic_id no JWT e no User da sessão.

Nas regras (e.g. get_patient) validamos se o recurso pertence à mesma clínica.

Essa é uma visão geral. A partir daqui, podemos detalhar qualquer camada (modelos, migrations, serviços, dependências FastAPI, hooks React etc.) — basta dizer qual parte quer aprofundar!






Você disse:
CERTO VAMAOS CRIA RUM DASHBAORD PARA CADA ROLE O QUE ACHA? TEM UMA IDEIA MELHOR?


O ChatGPT disse:

Pensou por alguns segundos
Criar um dashboard dedicado para cada role é uma abordagem bem direta e deixa claro ao usuário quais funcionalidades lhe cabem — mas existem algumas variações que podem tornar a experiência ainda mais flexível e enxuta. Veja abaixo três opções, com prós e contras, para você decidir qual se encaixa melhor:

1. Dashboards separados por role
Como funciona

Você cria rotas e layouts distintos (por exemplo /admin/dashboard, /clinic-owner/dashboard, /collab/dashboard, /patient/dashboard).

Cada rota monta um conjunto de cards, gráficos e menus específico daquela role.

Prós

Máxima clareza: cada tipo de usuário vê apenas o que interessa.

Separação física de código: mais fácil aplicar mudanças isoladas.

Contras

Mais duplicação de código (ajustes semelhantes podem acabar em arquivos diferentes).

Maior esforço de manutenção se você tiver muitos roles.

2. Dashboard único, com seções habilitadas por role
Como funciona

Há uma única rota de dashboard (/dashboard), mas você monta dinamicamente os widgets com base no perfil do usuário.

tsx
Copiar
Editar
const widgets = [
  { component: FinanceCard, roles: [ADMIN, DONO_CLINICA] },
  { component: PatientList, roles: [COLAB_N1, COLAB_N2, COLAB_N3] },
  { component: MyAppointments, roles: [PACIENTE] },
  // …
];
return (
  <DashboardLayout>
    {widgets.map(w =>
      user.hasAnyRole(w.roles) ? <w.component key={…}/> : null
    )}
  </DashboardLayout>
);
Prós

Código concentrado: lógica de layout e autorização num único lugar.

Facilidade para adicionar um novo widget e só configurar as roles que o veem.

Contras

Dashboard pode ficar “poluído” se não for bem organizado (precisa de seções claras).

Exige um pouco mais de abstração para gerenciar permissões no front.

3. Dashboard “modular” com configuração externa
Como funciona

Você define num JSON ou no banco de dados a configuração de cada role:

json
Copiar
Editar
{
  "ADMIN": ["finance", "tenants", "users", "reports"],
  "DONO_CLINICA": ["clinic-overview","users","inventory"],
  "COLAB_N1": ["my-patients","schedule"],
  "PACIENTE": ["my-profile","appointments"]
}
O front lê essa configuração e monta os cards/menus conforme o perfil.

Prós

Extremamente flexível: muda permissões e visibilidades sem deploy de código.

Ponto único de verdade (source of truth) para habilitar módulos.

Contras

Mais complexidade inicial: precisa endpoint para buscar config e interpretar.

Lógica de montagem um pouco mais genérica, exigindo uma camada de “widget factory”.

Qual escolher?
Se você tiver poucas roles (até 5–6) e quiser mais simplicidade, o método 1 (dashboards separados) funciona bem e é super claro.

Se preferir eficiência de manutenção e reduzir duplicação, o método 2 (único dashboard dinâmico) costuma ser o mais adotado em SaaS modernos.

Se antecipa muitas regras de negócio mudando ou novos módulos podendo surgir, o método 3 (configuração externa) dá mais poder ao time de produto sem precisar tocar código.

Também é possível mesclar: ter um dashboard separado para ADMIN e DONO_CLINICA (que têm visão global) e usar o dashboard único para COLAB/N e PACIENTE, por exemplo.

→ Me diz qual abordagem parece mais alinhada ao seu fluxo, ou se quiser que esboce um wireframe e exemplos de código para a opção escolhida!






Você disse:
bou ficar com metodo um


O ChatGPT disse:

Pensou por 7 segundos
Perfeito! Vamos seguir o Método 1 – dashboards totalmente separados. Aqui vai uma proposta de como organizar tudo, do roteamento ao layout e componentes, para cada role:

1. Estrutura de pastas
text
Copiar
Editar
src/
├─ layouts/
│  ├─ AdminLayout.tsx
│  ├─ ClinicOwnerLayout.tsx
│  ├─ CollaboratorLayout.tsx
│  └─ PatientLayout.tsx
├─ pages/
│  ├─ admin/
│  │  └─ Dashboard.tsx
│  ├─ owner/
│  │  └─ Dashboard.tsx
│  ├─ collaborator/
│  │  ├─ level1/
│  │  │  └─ Dashboard.tsx
│  │  ├─ level2/
│  │  │  └─ Dashboard.tsx
│  │  └─ level3/
│  │     └─ Dashboard.tsx
│  └─ patient/
│     └─ Dashboard.tsx
├─ components/
│  ├─ sidebar/
│  │  ├─ AdminSidebar.tsx
│  │  ├─ OwnerSidebar.tsx
│  │  ├─ CollaboratorSidebar.tsx
│  │  └─ PatientSidebar.tsx
│  └─ header/
│     └─ Header.tsx
└─ App.tsx
2. Roteamento (exemplo com Wouter)
No seu App.tsx, defina rotas hierárquicas:

tsx
Copiar
Editar
import { Route, Switch } from "wouter";
import AdminLayout from "./layouts/AdminLayout";
import ClinicOwnerLayout from "./layouts/ClinicOwnerLayout";
import CollaboratorLayout from "./layouts/CollaboratorLayout";
import PatientLayout from "./layouts/PatientLayout";

function App() {
  return (
    <Switch>
      {/* Admin */}
      <Route path="/admin">
        <AdminLayout />
      </Route>

      {/* Dono de Clínica */}
      <Route path="/owner">
        <ClinicOwnerLayout />
      </Route>

      {/* Colaboradores (níveis 1,2,3) */}
      <Route path="/collab/level1">
        <CollaboratorLayout level="n1" />
      </Route>
      <Route path="/collab/level2">
        <CollaboratorLayout level="n2" />
      </Route>
      <Route path="/collab/level3">
        <CollaboratorLayout level="n3" />
      </Route>

      {/* Paciente */}
      <Route path="/patient">
        <PatientLayout />
      </Route>
    </Switch>
  );
}
export default App;
Cada *Layout carrega seu próprio sidebar, header e vai renderizar a página de dashboard:

tsx
Copiar
Editar
// layouts/AdminLayout.tsx
import { Outlet } from "react-router-dom";
import AdminSidebar from "../components/sidebar/AdminSidebar";
import Header from "../components/header/Header";

export default function AdminLayout() {
  return (
    <div className="flex h-screen">
      <AdminSidebar />
      <div className="flex-1 flex flex-col">
        <Header />
        <main className="p-6">
          <Outlet />           {/* renderiza pages/admin/Dashboard.tsx */}
        </main>
      </div>
    </div>
  );
}
3. Dashboards: o que incluir em cada
Role	Conteúdo sugerido
ADMIN	• Visão global de tenants (gráfico de crescimento)
• Controle de usuários do sistema
• Logs e métricas SaaS
DONO_DE_CLÍNICA	• Overview financeiro da clínica (faturamento, custos)
• Gestão de usuários da clínica
• Status de módulos ativos
COLAB_N1	• Lista de pacientes atribuídos
• Agenda do dia
• Atalhos para cadastro de novos pacientes
COLAB_N2	• Todas as N1, mais:
• Controle de insumos e estoque
• Relatórios simplificados de atendimentos
COLAB_N3	• Todas as N2, mais:
• Permissões de edição de orçamentos
• Acesso a relatórios financeiros restritos
PACIENTE	• Meus dados cadastrais
• Minhas consultas agendadas
• Botão para solicitar novo agendamento

Dentro de cada pages/*/Dashboard.tsx você usaria componentes do ShadCN UI e Tailwind para montar um grid de cards, ex.:

tsx
Copiar
Editar
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";

export default function AdminDashboard() {
  return (
    <div className="grid grid-cols-3 gap-4">
      <Card>
        <CardHeader><CardTitle>Tenants Ativos</CardTitle></CardHeader>
        <CardContent>{/* gráfico ou número total */}</CardContent>
      </Card>
      <Card>
        <CardHeader><CardTitle>Novos Usuários</CardTitle></CardHeader>
        <CardContent>{/* tabela ou estatística */}</CardContent>
      </Card>
      {/* …outros cards */}
    </div>
  );
}
4. Proteção de rotas
Mantém no backend o require_roles(...) para cada rota (já definido antes). No frontend, seu PrivateRoute pode redirecionar se o usuário não tiver acesso àquela área:

tsx
Copiar
Editar
// exemplo simplificado
<Route path="/admin/*" element={<PrivateRoute allowed={[Role.ADMIN]} />}>
  <Route path="" element={<AdminLayout />} />
</Route>
Próximos passos
Criar os layouts (AdminLayout.tsx, etc.) e sidebars com menus específicos.

Implementar as páginas de Dashboard conforme tabela acima.

Ajustar o roteamento no App.tsx e garantir o guard de acesso.

Refinar os cards e gráficos usando ShadCN UI e Tailwind.

Se quiser, posso começar pelo AdminLayout + AdminDashboard com código completo e exemplos de UI. Me diga!






Você disse:
vamos seguir com proximos passos ja temos um padrao de layout como seria sua ideia? Layout Componentizado - HUBB Assist SaaS
Visão Geral
O HUBB Assist SaaS possui um layout totalmente componentizado seguindo princípios de design moderno e responsivo, construído com React + TypeScript + Tailwind CSS.

Estrutura de Componentes
Componentes Principais
1. AppShell.tsx
Localização: frontend/src/components/layout/AppShell.tsx
Função: Container principal da aplicação
Características:
Gerencia estado da sidebar (aberta/fechada)
Layout responsivo com grid CSS
Suporte para mobile com overlay
2. Header.tsx
Localização: frontend/src/components/layout/Header.tsx
Função: Cabeçalho da aplicação
Características:
Logo oficial HUBB
Botão de toggle da sidebar (mobile)
Navegação superior
Cores oficiais: Roxo (#2D113F) e Vermelho (#C52339)
3. Sidebar.tsx
Localização: frontend/src/components/layout/Sidebar.tsx
Função: Menu lateral de navegação
Características:
Desktop: 240px expandida, 60px colapsada
Mobile: Overlay com fundo escuro
Ícones Lucide React (brancos)
Animações suaves de transição
4. Dashboard.tsx
Localização: frontend/src/pages/Dashboard.tsx
Função: Página principal do dashboard
Características:
Cards dos módulos HUBB
Layout em grid responsivo
Estatísticas e métricas
Módulos HUBB
Módulos Implementados
HUBB HOF - Harmonização Orofacial com IA

Ícone: Sparkles
Cor: Gradient roxo/rosa
HUBB Vision - Processamento de Radiografias

Ícone: Eye
Cor: Gradient azul
HUBB RH - Gestão de Recursos Humanos

Ícone: Users
Cor: Gradient verde
HUBB IA - Assistente Virtual

Ícone: Bot
Cor: Gradient roxo
HUBB Core - Gestão Principal

Ícone: Building2
Cor: Gradient laranja
Configurações - Configurações do Sistema

Ícone: Settings
Cor: Gradient cinza
Design System
Cores Oficiais
--hubb-purple: #2D113F
--hubb-red: #C52339
Responsividade
Desktop (≥ 1024px)
Sidebar fixa lateral
Layout em 3 colunas
Cards em grid 3x2
Tablet (768px - 1023px)
Sidebar colapsável
Layout em 2 colunas
Cards em grid 2x3
Mobile (< 768px)
Sidebar overlay
Layout em 1 coluna
Cards empilhados
Configuração Técnica
Vite Configuration
// vite.config.js
export default defineConfig({
  plugins: [react()],
  server: {
    host: '0.0.0.0',
    port: 3000,
    allowedHosts: [
      'localhost',
      'hubb-assist-mono-fronteback-v1.replit.app',
      '.replit.app',
      '.spock.replit.dev'
    ],
    hmr: {
      port: 24678,
      host: '0.0.0.0'
    }
  }
})
PostCSS Configuration
// postcss.config.js
export default {
  plugins: {
    '@tailwindcss/postcss': {},
    autoprefixer: {},
  },
}
Tailwind Configuration
// tailwind.config.js
module.exports = {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        'hubb-purple': '#2D113F',
        'hubb-red': '#C52339'
      }
    },
  }
}
Estados de Componentes
Sidebar States
isSidebarOpen: boolean - Controla visibilidade
isMobile: boolean - Detecta dispositivo móvel
isCollapsed: boolean - Estado colapsado (desktop)
Responsive Breakpoints
sm: 640px
md: 768px
lg: 1024px
xl: 1280px
2xl: 1536px
Boas Práticas
Organização de Arquivos
frontend/src/
├── components/
│   ├── layout/
│   │   ├── AppShell.tsx
│   │   ├── Header.tsx
│   │   └── Sidebar.tsx
│   └── ui/
├── pages/
│   └── Dashboard.tsx
└── lib/
    └── utils.ts
Convenções de Nomenclatura
Componentes: PascalCase (AppShell.tsx)
Hooks: camelCase com prefixo use (useSidebar)
Utilitários: camelCase (cn, formatDate)
Constantes: UPPER_SNAKE_CASE (API_BASE_URL)
Acessibilidade
Todos os botões possuem aria-label
Navegação por teclado implementada
Contraste adequado nas cores
Suporte a screen readers
Troubleshooting
Problemas Comuns
1. Host Blocked Error
Erro: This host is not allowed Solução: Adicionar host no allowedHosts do vite.config.js

2. TailwindCSS não funciona
Erro: postcss plugin error Solução: Instalar @tailwindcss/postcss e configurar postcss.config.js

3. WebSocket connection failed
Erro: failed to connect to websocket Solução: Configurar HMR com porta específica

Comandos Úteis
# Instalar dependências
npm install
# Executar desenvolvimento
npm run dev
# Build para produção
npm run build
# Preview da build
npm run preview
Extensibilidade
Adicionando Novos Módulos
Criar componente em src/components/modules/
Adicionar rota em src/App.tsx
Incluir item na sidebar
Definir ícone Lucide apropriado
Aplicar gradient de cor único
Adicionando Novas Páginas
Criar arquivo em src/pages/
Importar e usar AppShell como wrapper
Configurar rota no React Router
Adicionar navegação se necessário
Este layout componentizado garante escalabilidade, manutenibilidade e uma experiência de usuário consistente em toda a aplicação HUBB Assist SaaS.


O ChatGPT disse:

Pensou por dois segundos
A seguir um plano de ação para, a partir desse padrão de layout já definido, implementar de forma ordenada e alinhada a DDD/SOLID/Clean Code:

1. Scaffold inicial dos componentes
Criar diretórios e arquivos vazios

bash
Copiar
Editar
mkdir -p src/components/layout
touch src/components/layout/{AppShell,Header,Sidebar}.tsx
mkdir -p src/pages/{admin,owner,collab/patient}
touch src/pages/{admin/ Dashboard.tsx,owner/Dashboard.tsx,collab/level1/Dashboard.tsx,collab/level2/Dashboard.tsx,collab/level3/Dashboard.tsx,patient/Dashboard.tsx}
Definir exports “barrel” (index.ts) em cada pasta para facilitar importações.

2. Implementar o AppShell
Objetivo: container único que orquestra Sidebar, Header e main

Estrutura básica:

tsx
Copiar
Editar
// src/components/layout/AppShell.tsx
import { ReactNode } from "react";
import useSidebar from "@/lib/hooks/useSidebar";
import Sidebar from "./Sidebar";
import Header from "./Header";

type AppShellProps = { children: ReactNode };
export default function AppShell({ children }: AppShellProps) {
  const { isOpen, toggle, isMobile } = useSidebar();
  return (
    <div className="flex h-screen">
      <Sidebar isOpen={isOpen} isMobile={isMobile} toggle={toggle} />
      <div className="flex-1 flex flex-col">
        <Header toggleSidebar={toggle} />
        <main className="flex-1 overflow-auto p-6">{children}</main>
      </div>
    </div>
  );
}
Hook useSidebar:

Detecta largura de tela (useMediaQuery)

Controla isOpen e isCollapsed

Expõe toggle() e flags

3. Montar Header e Sidebar
Header.tsx

Logo à esquerda (+ link para home)

Botão hamburger (mobile) e toggle (desktop)

Área para notificações/usuário no canto direito

Sidebar.tsx

Recebe isOpen, isMobile, toggle

Renderiza <nav> com lista de links (icons + labels)

Se isMobile && isOpen → overlay full-screen que fecha ao clicar fora

Se desktop e collapse → renderiza somente icons

4. Configurar Tailwind para estados e responsividade
No tailwind.config.js inclua:

js
Copiar
Editar
module.exports = {
  theme: {
    extend: {
      colors: {
        "hubb-purple": "#2D113F",
        "hubb-red": "#C52339",
      }
    }
  },
  variants: {
    extend: {
      transitionProperty: ["hover", "focus"],
    }
  }
};
Use classes como lg:hidden, md:grid-cols-2, grid-cols-1 para adaptar layouts.

5. Criar Layouts específicos por role
Cada role terá seu layout próprio estendendo o AppShell:

tsx
Copiar
Editar
// src/layouts/AdminLayout.tsx
import AppShell from "@/components/layout/AppShell";
import AdminSidebar from "@/components/sidebar/AdminSidebar";

export default function AdminLayout() {
  return (
    <AppShell>
      {/* aqui poderia substituir o Sidebar padrão por um customizado */}
      <AdminSidebar />
      <AdminDashboard />
    </AppShell>
  );
}
Replicar para OwnerLayout, CollaboratorLayout (recebendo level), PatientLayout.

6. Rotas e Guards
React Router / Wouter

Defina rotas aninhadas:

tsx
Copiar
Editar
<Route path="/admin/*" element={<PrivateRoute roles={["ADMIN"]}><AdminLayout/></PrivateRoute>} />
<PrivateRoute>

Recebe lista de roles permitidos

Consulta AuthContext (JWT decodificado)

Redireciona para /login ou /unauthorized

7. Construir as Dashboard Pages
Para cada pasta src/pages/*/Dashboard.tsx:

Importar Card e Grid do ShadCN UI

Seguir os layouts de grid especificados (3 col/2 col/1 col)

Exibir os módulos/cards sugeridos (tabela, gráficos, atalhos)

Exemplo básico:

tsx
Copiar
Editar
export default function AdminDashboard() {
  return (
    <div className="grid gap-4 lg:grid-cols-3 md:grid-cols-2 grid-cols-1">
      <Card><CardTitle>Tenants Ativos</CardTitle><Chart/></Card>
      <Card><CardTitle>Novos Usuários</CardTitle><Stat number={42}/></Card>
      {/* ... */}
    </div>
  );
}
8. Testes e documentação
Storybook

Configure stories para AppShell, Sidebar, Header, Card

Testes unitários

React Testing Library para checar comportamento de collapse, responsividade

Documentar

No README.md, inclua seção “Como rodar o layout” e “Como criar novo módulo”

